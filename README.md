# 포인터
포인터는 **주소**다.

```c
int a = 5;
&a; // 변수 a의 주소 -> 5라는 값이 있는 곳
```

## 포인터 변수
포인터 변수는 **포인터를 저장하기 위한 변수** 다.

### 포인터 변수를 왜 사용할까?
```c
int a = 5;
int p = &a;
printf("%d\n", p); // -310942164
int *q = &a;
printf("%d\n", q); // -310942164
```
여기까지만 보면
> 어? 굳이 `*`자 하나 더 붙여서 포인터 변수를 사용할 이유가 뭐가 있어?

```c
printf("%d\n", *(&a)); // 5
printf("%d\n", *p); // 컴파일 에러! 
printf("%d\n", *q); // 5
```
> ???

- 에러가 난 이유: `*` 연산자는 피연산자로 주소를 넣어야 하는데 `p`는 주소가 아니라 정수 타입이기 때문에!

- 포인터 변수를 사용하는 이유: **정수 형태인 주소값을 일반적인 정수값과 구분** 해야 하므로.
- 일반 정수(`int`)랑 주소(`int *`)는 **같은 타입이 아니다!**
- 저렇게 `p`처럼 그냥 변수에 대입하면 `int`로 강제로 바뀌어 버리면서 컴파일할 때 경고도 나오고, 주소처럼 참고하려고 하면 에러가 떠 버린다.

```
why-pointer.c:4:7: warning: incompatible pointer to integer conversion initializing 'int' with an expression of type 'int *';
      remove & [-Wint-conversion]
  int p = &a;
```

경고를 읽어보면 생각이 가능했던 부분이더라...

### 포인터 변수의 자료형
그렇다고 포인터 변수의 타입이 무조건 `int *`인 건 아니다!

`char` 변수에 대한 포인터의 타입은 `char *`고, `double`에 대한 건 `double *`이다.

즉 **포인터 변수의 자료형은 그 포인터가 가리키는 변수의 자료형에 따라 달라진다.**

```c
int a = 5;
int *p = &a;
```
> `*p` 연산을 하기 위해서는 `p` 구조에 **들어 있는 데이터의 타입을 알아야** 정확하게 데이터를 가져올 수 있다.

- 근데 쌤이 계속 포인터 변수 `p`의 타입이 `int *`가 아니고 `int`라고 하셔서 자료를 찾아갔다.

- https://stackoverflow.com/questions/26976496/what-is-the-data-type-of-pointer-variables

- 꺄르르

- 포인터 변수의 타입을 묻는 문제는 시험에 안 나온다고 하셨다.
